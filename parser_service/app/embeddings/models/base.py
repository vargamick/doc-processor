from abc import ABC, abstractmethod
from typing import List, Optional, Dict, Any, Union, TypeVar, Sequence, cast
from typing_extensions import TypeAlias
import torch
import numpy as np
from numpy.typing import NDArray

from ..config.model_config import ModelConfig

# Type aliases for tensor operations
FloatArray = NDArray[np.float32]
FloatTensor = torch.Tensor
SingleTensor = Union[FloatTensor, FloatArray]
TensorList = Sequence[FloatTensor]
ModelOutput = Union[SingleTensor, TensorList]

# Type aliases for embedding outputs
SingleEmbedding: TypeAlias = List[float]
BatchEmbeddings: TypeAlias = List[List[float]]


class IEmbeddingModel(ABC):
    """Abstract base class for embedding model implementations"""

    def __init__(self, config: ModelConfig):
        """Initialize the embedding model with configuration"""
        self.config = config
        self._model: Any = self._initialize_model()

    @abstractmethod
    def _initialize_model(self) -> Any:
        """Initialize the underlying model"""
        pass

    @abstractmethod
    def _convert_output(
        self, output: ModelOutput, is_batch: bool = False
    ) -> Union[SingleEmbedding, BatchEmbeddings]:
        """Convert model output to appropriate embedding format"""
        pass

    @abstractmethod
    def encode(self, text: str) -> SingleEmbedding:
        """Generate embedding for a single text"""
        pass

    @abstractmethod
    def encode_batch(
        self, texts: Sequence[str], batch_size: Optional[int] = None
    ) -> BatchEmbeddings:
        """Generate embeddings for a batch of texts"""
        pass

    @abstractmethod
    def get_embedding_dimension(self) -> int:
        """Get the dimension of the embeddings generated by this model"""
        pass

    @abstractmethod
    def get_model_info(self) -> Dict[str, Any]:
        """Get information about the model configuration"""
        pass

    def to_device(self, device: str) -> None:
        """Move model to specified device if supported"""
        pass
